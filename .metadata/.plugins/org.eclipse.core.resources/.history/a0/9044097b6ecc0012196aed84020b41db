 

import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

import javafx.concurrent.Task;
import javafx.scene.Scene;
import javafx.scene.control.ProgressIndicator;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.ProgressBarTableCell;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.BorderPane;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;

import org.eclipse.e4.ui.di.Focus;
import org.eclipse.e4.ui.di.Persist;

public class TestPart {
	@Inject
	public TestPart() {
		//TODO Your code here
	}
	
	@PostConstruct
	public void postConstruct(BorderPane pane) {
		table = new TableView<TestTask>();
	    Random rng = new Random();
	    for (int i = 0; i < 20; i++) {
	      table.getItems().add(
	          new TestTask(rng.nextInt(3000) + 2000, rng.nextInt(30) + 20));
	    }

	    TableColumn<TestTask, String> statusCol = new TableColumn("Status");
	    statusCol.setCellValueFactory(new PropertyValueFactory<TestTask, String>(
	        "message"));
	    statusCol.setPrefWidth(75);

	    TableColumn<TestTask, Double> progressCol = new TableColumn("Progress");
	    progressCol.setCellValueFactory(new PropertyValueFactory<TestTask, Double>(
	        "progress"));
	    progressCol
	        .setCellFactory(ProgressBarTableCell.<TestTask> forTableColumn());

	    table.getColumns().addAll(statusCol, progressCol);

	    pane.setCenter(table);
	    executor = Executors.newFixedThreadPool(table.getItems().size(), new ThreadFactory() {
	      @Override
	      public Thread newThread(Runnable r) {
	        Thread t = new Thread(r);
	        t.setDaemon(true);
	        return t;
	      }
	    });
	}
	
	@Focus
	public void onFocus() {
		for (TestTask task : table.getItems()) {
		      executor.execute(task);
		    }
	}
	
	private TableView<TestTask> table;
	private ExecutorService executor;
	
	static class TestTask extends Task<Void> {

	    private final int waitTime; // milliseconds
	    private final int pauseTime; // milliseconds

	    public static final int NUM_ITERATIONS = 100;

	    TestTask(int waitTime, int pauseTime) {
	      this.waitTime = waitTime;
	      this.pauseTime = pauseTime;
	    }

	    @Override
	    protected Void call() throws Exception {
	      this.updateProgress(ProgressIndicator.INDETERMINATE_PROGRESS, 1);
	      this.updateMessage("Waiting...");
	      Thread.sleep(waitTime);
	      this.updateMessage("Running...");
	      for (int i = 0; i < NUM_ITERATIONS; i++) {
	        updateProgress((1.0 * i) / NUM_ITERATIONS, 1);
	        Thread.sleep(pauseTime);
	      }
	      this.updateMessage("Done");
	      this.updateProgress(1, 1);
	      return null;
	    }

	  }
	
	
	@PreDestroy
	public void preDestroy() {
		//TODO Your code here
	}
	
	@Persist
	public void save() {
		//TODO Your code here
	}
	
}